## File: `bohe_backend\alembic\env.py`

```
"""Pyramid bootstrap environment. """
from alembic import context
from pyramid.paster import get_appsettings, setup_logging
from sqlalchemy import engine_from_config

from bohe_backend.models.meta import Base

config = context.config

setup_logging(config.config_file_name)

settings = get_appsettings(config.config_file_name)
target_metadata = Base.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    context.configure(url=settings['sqlalchemy.url'])
    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    engine = engine_from_config(settings, prefix='sqlalchemy.')

    connection = engine.connect()
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    try:
        with context.begin_transaction():
            context.run_migrations()
    finally:
        connection.close()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

```

## File: `bohe_backend\alembic\script.py.mako`

```
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade():
    ${upgrades if upgrades else "pass"}


def downgrade():
    ${downgrades if downgrades else "pass"}

```

## File: `bohe_backend\alembic\versions\20250531_53639a18404b.py`

```
"""create bohe table

Revision ID: 53639a18404b
Revises:
Create Date: 2025-05-31 20:23:59.920660

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '53639a18404b'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('products',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('price', sa.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('image_url', sa.String(), nullable=True),
    sa.Column('stock', sa.Integer(), server_default='0', nullable=False),
    sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_products'))
    )
    op.create_table('users',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('username', sa.String(), nullable=False),
    sa.Column('email', sa.String(), nullable=False),
    sa.Column('password', sa.String(), nullable=False),
    sa.Column('role', sa.String(), server_default='user', nullable=False),
    sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_users')),
    sa.UniqueConstraint('email', name=op.f('uq_users_email')),
    sa.UniqueConstraint('username', name=op.f('uq_users_username'))
    )
    op.create_table('orders',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('user_id', sa.String(), nullable=False),
    sa.Column('order_date', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.Column('total_amount', sa.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('customer_name', sa.String(), nullable=False),
    sa.Column('phone_number', sa.String(), nullable=False),
    sa.Column('address', sa.Text(), nullable=False),
    sa.Column('payment_method', sa.String(), nullable=False),
    sa.Column('status', sa.String(), server_default='pending_payment', nullable=False),
    sa.Column('proof_of_payment_url', sa.String(), nullable=True),
    sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_orders_user_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_orders'))
    )
    op.create_table('order_items',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('order_id', sa.String(), nullable=False),
    sa.Column('product_id', sa.String(), nullable=False),
    sa.Column('quantity', sa.Integer(), nullable=False),
    sa.Column('price_at_purchase', sa.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.ForeignKeyConstraint(['order_id'], ['orders.id'], name=op.f('fk_order_items_order_id_orders')),
    sa.ForeignKeyConstraint(['product_id'], ['products.id'], name=op.f('fk_order_items_product_id_products')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_order_items'))
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('order_items')
    op.drop_table('orders')
    op.drop_table('users')
    op.drop_table('products')
    # ### end Alembic commands ###

```

## File: `bohe_backend\alembic\versions\README.txt`

```
Placeholder for alembic versions
```

## File: `bohe_backend\models\meta.py`

```
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.schema import MetaData

# Recommended naming convention used by Alembic, as various different database
# providers will autogenerate vastly different names making migrations more
# difficult. See: http://alembic.zzzcomputing.com/en/latest/naming.html
NAMING_CONVENTION = {
    "ix": "ix_%(column_0_label)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s"
}

metadata = MetaData(naming_convention=NAMING_CONVENTION)
Base = declarative_base(metadata=metadata)

```

## File: `bohe_backend\models\order.py`

```
from sqlalchemy import Column, String, Text, DECIMAL, TIMESTAMP, ForeignKey, text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from .meta import Base
import uuid

class Order(Base):
    __tablename__ = 'orders'

    id = Column(String, primary_key=True)
    user_id = Column(String, ForeignKey('users.id'), nullable=False)
    order_date = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"))
    total_amount = Column(DECIMAL(10, 2), nullable=False)
    customer_name = Column(String, nullable=False)
    phone_number = Column(String, nullable=False)
    address = Column(Text, nullable=False)
    payment_method = Column(String, nullable=False)
    status = Column(String, nullable=False, server_default='pending_payment')
    proof_of_payment_url = Column(String)
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"), onupdate=text("CURRENT_TIMESTAMP"))

    user = relationship("User", backref="orders")
    items = relationship("OrderItem", back_populates="order")

    def to_dict(self):
        return {
            "id": str(self.id),
            "user_id": str(self.user_id),
            "order_date": self.order_date.isoformat(),
            "total_amount": float(self.total_amount),
            "customer_name": self.customer_name,
            "phone_number": self.phone_number,
            "address": self.address,
            "payment_method": self.payment_method,
            "status": self.status,
            "proof_of_payment_url": self.proof_of_payment_url,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
        }

    def __repr__(self):
        return f"<Order(id='{self.id}', user_id='{self.user_id}', total_amount='{self.total_amount}', status='{self.status}')>"
```

## File: `bohe_backend\models\order_item.py`

```
from sqlalchemy import Column, String, Integer, DECIMAL, TIMESTAMP, ForeignKey, text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from .meta import Base
import uuid

class OrderItem(Base):
    __tablename__ = 'order_items'

    id = Column(String, primary_key=True)
    order_id = Column(String, ForeignKey('orders.id'), nullable=False)
    product_id = Column(String, ForeignKey('products.id'), nullable=False)
    quantity = Column(Integer, nullable=False)
    price_at_purchase = Column(DECIMAL(10, 2), nullable=False)
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"), onupdate=text("CURRENT_TIMESTAMP"))

    order = relationship("Order", back_populates="items")
    product = relationship("Product")

    def to_dict(self):
        return {
            "id": str(self.id),
            "order_id": str(self.order_id),
            "product_id": str(self.product_id),
            "quantity": self.quantity,
            "price_at_purchase": float(self.price_at_purchase),
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
        }

    def __repr__(self):
        return f"<OrderItem(order_id='{self.order_id}', product_id='{self.product_id}', quantity='{self.quantity}')>"
```

## File: `bohe_backend\models\product.py`

```
from sqlalchemy import Column, String, Text, DECIMAL, Integer, TIMESTAMP, text
from sqlalchemy.dialects.postgresql import UUID
from .meta import Base
import uuid

class Product(Base):
    __tablename__ = 'products'

    id = Column(String, primary_key=True)
    name = Column(String, nullable=False)
    description = Column(Text)
    price = Column(DECIMAL(10, 2), nullable=False)
    image_url = Column(String)
    stock = Column(Integer, nullable=False, server_default='0')
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"), onupdate=text("CURRENT_TIMESTAMP"))

    def to_dict(self):
        return {
            "id": str(self.id),
            "name": self.name,
            "description": self.description,
            "price": float(self.price),
            "image_url": self.image_url,
            "stock": self.stock,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
        }

    def __repr__(self):
        return f"<Product(name='{self.name}', price='{self.price}', stock='{self.stock}')>"
```

## File: `bohe_backend\models\user.py`

```
from sqlalchemy import Column, String, TIMESTAMP, text
from sqlalchemy.dialects.postgresql import UUID
from .meta import Base
from passlib.hash import bcrypt
import uuid

class User(Base):
    __tablename__ = 'users'

    id = Column(String, primary_key=True)
    username = Column(String, nullable=False, unique=True)
    email = Column(String, nullable=False, unique=True)
    password = Column(String, nullable=False)
    role = Column(String, nullable=False, server_default='user')
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"), onupdate=text("CURRENT_TIMESTAMP"))

    def set_password(self, raw_password):
        self.password = bcrypt.hash(raw_password)

    def check_password(self, raw_password):
        return bcrypt.verify(raw_password, self.password)

    def to_dict(self):
        return {
            "id": str(self.id),
            "username": self.username,
            "email": self.email,
            "role": self.role,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
        }

    def __repr__(self):
        return f"<User(username='{self.username}', email='{self.email}', role='{self.role}')>"
```

## File: `bohe_backend\models\__init__.py`

```
from sqlalchemy import engine_from_config
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import configure_mappers
import zope.sqlalchemy

# import or define all models here to ensure they are attached to the
# Base.metadata prior to any initialization routines

from .meta import Base
from .user import User
from .product import Product
from .order import Order
from .order_item import OrderItem

# run configure_mappers after defining all of the models to ensure
# all relationships can be setup
configure_mappers()


def get_engine(settings, prefix='sqlalchemy.'):
    return engine_from_config(settings, prefix)


def get_session_factory(engine):
    factory = sessionmaker()
    factory.configure(bind=engine)
    return factory


def get_tm_session(session_factory, transaction_manager):
    """
    Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.

    This function will hook the session to the transaction manager which
    will take care of committing any changes.

    - When using pyramid_tm it will automatically be committed or aborted
      depending on whether an exception is raised.

    - When using scripts you should wrap the session in a manager yourself.
      For example::

          import transaction

          engine = get_engine(settings)
          session_factory = get_session_factory(engine)
          with transaction.manager:
              dbsession = get_tm_session(session_factory, transaction.manager)

    """
    dbsession = session_factory()
    zope.sqlalchemy.register(
        dbsession, transaction_manager=transaction_manager)
    return dbsession


def includeme(config):
    """
    Initialize the model for a Pyramid app.

    Activate this setup using ``config.include('bohe_backend.models')``.

    """
    settings = config.get_settings()
    settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager'

    # use pyramid_tm to hook the transaction lifecycle to the request
    config.include('pyramid_tm')

    # use pyramid_retry to retry a request when transient exceptions occur
    config.include('pyramid_retry')

    session_factory = get_session_factory(get_engine(settings))
    config.registry['dbsession_factory'] = session_factory

    # make request.dbsession available for use in Pyramid
    config.add_request_method(
        # r.tm is the transaction manager used by pyramid_tm
        lambda r: get_tm_session(session_factory, r.tm),
        'dbsession',
        reify=True
    )

```

## File: `bohe_backend\scripts\initialize_db.py`

```
import argparse
import sys
import uuid
from datetime import datetime

from pyramid.paster import bootstrap, setup_logging
from sqlalchemy.exc import OperationalError

from ..models.user import User
from ..models.product import Product
from ..models.order import Order
from ..models.order_item import OrderItem


def setup_models(dbsession):
    """
    Add sample data for the Bohe perfume e-commerce database.
    """
    print("Seeding sample data...")

    # Sample User
    user1_id = str(uuid.uuid4())
    user1 = User(
        id=user1_id,
        username="john_doe",
        email="john.doe@example.com",
        role="user",
    )
    user1.set_password("securepassword123")

    user2_id = str(uuid.uuid4())
    user2 = User(
        id=user2_id,
        username="jane_admin",
        email="jane.admin@example.com",
        role="admin",
    )
    user2.set_password("adminpassword123")

    dbsession.add_all([user1, user2])
    print("Users added.")

    # Sample Products
    product1_id = str(uuid.uuid4())
    product1 = Product(
        id=product1_id,
        name="Bohe Classic Eau de Parfum",
        description="A timeless and elegant fragrance with notes of rose and sandalwood.",
        price=75.00,
        image_url="https://example.com/bohe-classic.jpg",
        stock=100,
    )

    product2_id = str(uuid.uuid4())
    product2 = Product(
        id=product2_id,
        name="Bohe Fresh Mist",
        description="A light and refreshing body mist, perfect for daily use.",
        price=30.50,
        image_url="https://example.com/bohe-fresh.jpg",
        stock=200,
    )

    product3_id = str(uuid.uuid4())
    product3 = Product(
        id=product3_id,
        name="Bohe Oud Intense",
        description="Deep and rich oud fragrance for a sophisticated evening.",
        price=120.00,
        image_url="https://example.com/bohe-oud.jpg",
        stock=50,
    )

    dbsession.add_all([product1, product2, product3])
    print("Products added.")

    # Sample Order for user1
    order1_id = str(uuid.uuid4())
    order1 = Order(
        id=order1_id,
        user_id=user1.id,
        order_date=datetime.now(),
        total_amount=0.00, # Will be calculated by order items
        customer_name="John Doe",
        phone_number="081234567890",
        address="Jl. Melati No. 10, Kota Metro, Lampung",
        payment_method="QRIS",
        status="completed",
        proof_of_payment_url="https://example.com/proof_payment_order1.jpg",
    )
    dbsession.add(order1)
    dbsession.flush() # Flush to get order1.id for order items

    # Sample Order Items for order1
    order_item1_id = str(uuid.uuid4())
    order_item1 = OrderItem(
        id=order_item1_id,
        order_id=order1.id,
        product_id=product1.id,
        quantity=2,
        price_at_purchase=product1.price,
    )

    order_item2_id = str(uuid.uuid4())
    order_item2 = OrderItem(
        id=order_item2_id,
        order_id=order1.id,
        product_id=product2.id,
        quantity=1,
        price_at_purchase=product2.price,
    )

    dbsession.add_all([order_item1, order_item2])
    print("Order and Order Items added.")

    # Update total_amount for order1 based on its items
    order1.total_amount = (order_item1.quantity * order_item1.price_at_purchase) + \
                          (order_item2.quantity * order_item2.price_at_purchase)
    dbsession.add(order1) # Re-add to persist the update

    print("Sample data seeding complete.")


def parse_args(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'config_uri',
        help='Configuration file, e.g., development.ini',
    )
    return parser.parse_args(argv[1:])


def main(argv=sys.argv):
    args = parse_args(argv)
    setup_logging(args.config_uri)
    env = bootstrap(args.config_uri)

    try:
        with env['request'].tm:
            dbsession = env['request'].dbsession
            setup_models(dbsession)
            print("✅ Sample data inserted successfully.")
    except OperationalError as err:
        print("❌ OperationalError:", err)
        print('''
Database connection failed. Possible causes:
1. You may need to initialize the tables using alembic: `alembic upgrade head`
2. The database server may not be running or misconfigured in development.ini.
''')
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        print("Please check your database models and connection.")
```

## File: `bohe_backend\scripts\__init__.py`

```
# package

```

## File: `bohe_backend\views\auth.py`

```
from pyramid.view import view_config
from pyramid.response import Response
from pyramid.httpexceptions import HTTPBadRequest, HTTPConflict, HTTPUnauthorized
from pyramid.security import remember, forget
from ..models.user import User
from uuid import uuid4

def require_fields(data, required_fields):
    missing = [f for f in required_fields if not data.get(f)]
    if missing:
        raise HTTPBadRequest(json_body={'error': f'Missing fields: {", ".join(missing)}'})

@view_config(route_name='register', request_method='POST', renderer='json')
def register(request):
    data = request.json_body

    try:
        require_fields(data, ['username', 'email', 'password'])
    except HTTPBadRequest as e:
        return e

    username = data['username']
    email = data['email']
    password = data['password']
    role = data.get('role', 'user')

    if request.dbsession.query(User).filter_by(email=email).first():
        return HTTPConflict(json_body={'error': 'Email already exists'})

    if request.dbsession.query(User).filter_by(username=username).first():
        return HTTPConflict(json_body={'error': 'Username already exists'})

    new_user = User(
        id=str(uuid4()),
        username=username,
        email=email,
        role=role
    )
    new_user.set_password(password)
    request.dbsession.add(new_user)
    request.dbsession.flush()

    return {
        'message': 'Registration successful',
        'user': new_user.to_dict()
    }

@view_config(route_name='login', request_method='POST', renderer='json')
def login(request):
    data = request.json_body

    try:
        require_fields(data, ['email', 'password'])
    except HTTPBadRequest as e:
        return e

    email = data['email']
    password = data['password']
    user = request.dbsession.query(User).filter_by(email=email).first()

    if not user or not user.check_password(password):
        return HTTPUnauthorized(json_body={'error': 'Invalid credentials'})

    headers = remember(request, user.id)

    return Response(
        json_body={
            'message': 'Login successful',
            'user': user.to_dict()
        },
        headers=headers,
        content_type='application/json'
    )

@view_config(route_name='logout', request_method='POST', renderer='json')
def logout(request):
    headers = forget(request)

    return Response(
        json_body={'message': 'Logout successful'},
        headers=headers,
        content_type='application/json'
    )

```

## File: `bohe_backend\views\default.py`

```
from pyramid.response import Response
from pyramid.view import view_config

@view_config(route_name='home', renderer='json')
def home_view(request):
    return {'message': 'Welcome to Bohe API'}
```

## File: `bohe_backend\views\notfound.py`

```
from pyramid.view import notfound_view_config

@notfound_view_config(renderer='../templates/404.jinja2')
def notfound_view(request):
    request.response.status = 404
    return {}

```

## File: `bohe_backend\views\orders.py`

```
from pyramid.view import view_config
from pyramid.httpexceptions import HTTPNotFound, HTTPBadRequest, HTTPForbidden, HTTPUnauthorized
from sqlalchemy.exc import IntegrityError
from uuid import uuid4
from datetime import datetime
from ..models.order import Order
from ..models.order_item import OrderItem
from ..models.product import Product
from ..security import is_admin

def require_fields(data, required_fields):
    missing = [f for f in required_fields if not data.get(f)]
    if missing:
        raise HTTPBadRequest(json_body={'error': f'Missing fields: {", ".join(missing)}'})

# View to list all orders (admin only)
@view_config(route_name='orders', request_method='GET', renderer='json', permission='admin_access')
def get_all_orders(request):
    if not is_admin(request):
        raise HTTPForbidden(json_body={'error': 'Access denied: Admin role required'})

    orders = request.dbsession.query(Order).all()
    return {'orders': [o.to_dict() for o in orders]}

# View to list orders for the authenticated user (user or admin)
@view_config(route_name='my_orders', request_method='GET', renderer='json', permission='user_access')
def get_my_orders(request):
    userid = request.authenticated_userid
    if not userid:
        raise HTTPUnauthorized(json_body={'error': 'Authentication required'})

    orders = request.dbsession.query(Order).filter_by(user_id=userid).all()
    return {'orders': [o.to_dict() for o in orders]}

# View to get a single order by ID (owner or admin only)
@view_config(route_name='order_by_id', request_method='GET', renderer='json', permission='user_access')
def get_order(request):
    order_id = request.matchdict['id']
    order = request.dbsession.query(Order).filter_by(id=order_id).first()
    if not order:
        raise HTTPNotFound(json_body={'error': 'Order not found'})

    userid = request.authenticated_userid
    if not userid:
        raise HTTPUnauthorized(json_body={'error': 'Authentication required'})

    if not is_admin(request) and str(order.user_id) != userid:
        raise HTTPForbidden(json_body={'error': 'Access denied: You can only view your own orders'})

    return order.to_dict()

# View to create a new order (authenticated users)
@view_config(route_name='orders', request_method='POST', renderer='json', permission='user_access')
def create_order(request):
    userid = request.authenticated_userid
    if not userid:
        raise HTTPUnauthorized(json_body={'error': 'Authentication required'})

    data = request.json_body
    try:
        require_fields(data, ['customer_name', 'phone_number', 'address', 'payment_method', 'items'])
        if not isinstance(data['items'], list) or not data['items']:
            raise HTTPBadRequest(json_body={'error': 'Invalid or empty "items" list'})
    except HTTPBadRequest as e:
        return e

    try:
        new_order = Order(
            id=str(uuid4()),
            user_id=userid,
            customer_name=data['customer_name'],
            phone_number=data['phone_number'],
            address=data['address'],
            payment_method=data['payment_method'],
            status=data.get('status', 'pending_payment'),
            proof_of_payment_url=data.get('proof_of_payment_url'),
            total_amount=0.00
        )
        request.dbsession.add(new_order)
        request.dbsession.flush()

        total_amount = 0
        for item_data in data['items']:
            require_fields(item_data, ['product_id', 'quantity'])
            product = request.dbsession.query(Product).filter_by(id=item_data['product_id']).first()
            if not product:
                raise HTTPBadRequest(json_body={'error': f"Product with ID {item_data['product_id']} not found"})
            if item_data['quantity'] <= 0:
                raise HTTPBadRequest(json_body={'error': 'Quantity must be positive'})
            if product.stock < item_data['quantity']:
                raise HTTPBadRequest(json_body={'error': f"Insufficient stock for product {product.name}. Available: {product.stock}"})

            new_order_item = OrderItem(
                id=str(uuid4()),
                order_id=new_order.id,
                product_id=product.id,
                quantity=item_data['quantity'],
                price_at_purchase=product.price
            )
            request.dbsession.add(new_order_item)
            total_amount += (new_order_item.quantity * new_order_item.price_at_purchase)

            product.stock -= item_data['quantity']
            request.dbsession.add(product)

        new_order.total_amount = total_amount
        request.dbsession.add(new_order)

        return {'message': 'Order created successfully', 'order': new_order.to_dict()}
    except IntegrityError:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': 'Failed to create order. Check data integrity.'})
    except HTTPBadRequest as e:
        request.dbsession.rollback()
        return e
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': f'An error occurred: {e}'})

# View to update order status (admin only)
@view_config(route_name='order_by_id', request_method='PUT', renderer='json', permission='admin_access')
def update_order(request):
    if not is_admin(request):
        raise HTTPForbidden(json_body={'error': 'Access denied: Admin role required'})

    order_id = request.matchdict['id']
    order = request.dbsession.query(Order).filter_by(id=order_id).first()
    if not order:
        raise HTTPNotFound(json_body={'error': 'Order not found'})

    data = request.json_body

    allowed_status_updates = ['pending_payment', 'waiting_confirmation', 'processing', 'shipped', 'completed', 'cancelled']
    if 'status' in data:
        if data['status'] not in allowed_status_updates:
            raise HTTPBadRequest(json_body={'error': 'Invalid status value'})
        order.status = data['status']
    if 'proof_of_payment_url' in data:
        order.proof_of_payment_url = data['proof_of_payment_url']
    if 'customer_name' in data:
        order.customer_name = data['customer_name']
    if 'phone_number' in data:
        order.phone_number = data['phone_number']
    if 'address' in data:
        order.address = data['address']
    if 'payment_method' in data:
        order.payment_method = data['payment_method']

    try:
        request.dbsession.flush()
        return {'message': 'Order updated successfully', 'order': order.to_dict()}
    except IntegrityError:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': 'Failed to update order. Check data integrity.'})
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': f'An error occurred: {e}'})

# View to delete an order (admin only)
@view_config(route_name='order_by_id', request_method='DELETE', renderer='json', permission='admin_access')
def delete_order(request):
    if not is_admin(request):
        raise HTTPForbidden(json_body={'error': 'Access denied: Admin role required'})

    order_id = request.matchdict['id']
    order = request.dbsession.query(Order).filter_by(id=order_id).first()
    if not order:
        raise HTTPNotFound(json_body={'error': 'Order not found'})

    try:
        request.dbsession.query(OrderItem).filter_by(order_id=order.id).delete()
        request.dbsession.delete(order)
        return {'message': 'Order deleted successfully'}
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': f'Failed to delete order: {e}'})

```

## File: `bohe_backend\views\order_items.py`

```
from pyramid.view import view_config
from pyramid.httpexceptions import HTTPNotFound, HTTPForbidden, HTTPUnauthorized
from ..models.order_item import OrderItem
from ..models.order import Order
from ..security import is_admin

# View to list all order items for a specific order (owner or admin only)
@view_config(route_name='order_items_by_order', request_method='GET', renderer='json', permission='user_access')
def get_order_items_for_order(request):
    order_id = request.matchdict['order_id']
    order = request.dbsession.query(Order).filter_by(id=order_id).first()
    if not order:
        raise HTTPNotFound(json_body={'error': 'Order not found'})

    userid = request.authenticated_userid
    if not userid:
        raise HTTPUnauthorized(json_body={'error': 'Authentication required'})

    if not is_admin(request) and str(order.user_id) != userid:
        raise HTTPForbidden(json_body={'error': 'Access denied: You can only view items of your own orders'})

    order_items = request.dbsession.query(OrderItem).filter_by(order_id=order_id).all()
    return {'order_items': [oi.to_dict() for oi in order_items]}

# View to get a single order item by ID (owner of order or admin only)
@view_config(route_name='order_item_by_id', request_method='GET', renderer='json', permission='user_access')
def get_order_item(request):
    order_item_id = request.matchdict['id']
    order_item = request.dbsession.query(OrderItem).filter_by(id=order_item_id).first()
    if not order_item:
        raise HTTPNotFound(json_body={'error': 'Order item not found'})

    order = request.dbsession.query(Order).filter_by(id=order_item.order_id).first()

    userid = request.authenticated_userid
    if not userid:
        raise HTTPUnauthorized(json_body={'error': 'Authentication required'})

    if not is_admin(request) and (not order or str(order.user_id) != userid):
        raise HTTPForbidden(json_body={'error': 'Access denied: You can only view items of your own orders'})

    return order_item.to_dict()

```

## File: `bohe_backend\views\products.py`

```
from pyramid.view import view_config
from pyramid.httpexceptions import HTTPNotFound, HTTPBadRequest, HTTPForbidden
from sqlalchemy.exc import IntegrityError
from uuid import uuid4
from ..models.product import Product
from ..security import is_admin

def require_fields(data, required_fields):
    missing = [f for f in required_fields if not data.get(f)]
    if missing:
        raise HTTPBadRequest(json_body={'error': f'Missing fields: {", ".join(missing)}'})

# View to list all products (publicly accessible)
@view_config(route_name='products', request_method='GET', renderer='json', permission='public_access')
def get_products(request):
    products = request.dbsession.query(Product).all()
    return {'products': [p.to_dict() for p in products]}

# View to get a single product by ID (publicly accessible)
@view_config(route_name='product_by_id', request_method='GET', renderer='json', permission='public_access')
def get_product(request):
    product_id = request.matchdict['id']
    product = request.dbsession.query(Product).filter_by(id=product_id).first()
    if not product:
        raise HTTPNotFound(json_body={'error': 'Product not found'})
    return product.to_dict()

# View to create a new product (admin only)
@view_config(route_name='products', request_method='POST', renderer='json', permission='admin_access')
def create_product(request):
    if not is_admin(request):
        raise HTTPForbidden(json_body={'error': 'Access denied: Admin role required'})

    data = request.json_body
    try:
        require_fields(data, ['name', 'price', 'stock'])
    except HTTPBadRequest as e:
        return e

    try:
        new_product = Product(
            id=str(uuid4()),
            name=data['name'],
            description=data.get('description'),
            price=data['price'],
            image_url=data.get('image_url'),
            stock=data['stock']
        )
        request.dbsession.add(new_product)
        request.dbsession.flush()
        return {'message': 'Product created successfully', 'product': new_product.to_dict()}
    except IntegrityError:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': 'Failed to create product. Check data integrity.'})
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': f'An error occurred: {e}'})

# View to update an existing product (admin only)
@view_config(route_name='product_by_id', request_method='PUT', renderer='json', permission='admin_access')
def update_product(request):
    if not is_admin(request):
        raise HTTPForbidden(json_body={'error': 'Access denied: Admin role required'})

    product_id = request.matchdict['id']
    product = request.dbsession.query(Product).filter_by(id=product_id).first()
    if not product:
        raise HTTPNotFound(json_body={'error': 'Product not found'})

    data = request.json_body

    if 'name' in data:
        product.name = data['name']
    if 'description' in data:
        product.description = data['description']
    if 'price' in data:
        product.price = data['price']
    if 'image_url' in data:
        product.image_url = data['image_url']
    if 'stock' in data:
        product.stock = data['stock']

    try:
        request.dbsession.flush()
        return {'message': 'Product updated successfully', 'product': product.to_dict()}
    except IntegrityError:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': 'Failed to update product. Check data integrity.'})
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': f'An error occurred: {e}'})

# View to delete a product (admin only)
@view_config(route_name='product_by_id', request_method='DELETE', renderer='json', permission='admin_access')
def delete_product(request):
    if not is_admin(request):
        raise HTTPForbidden(json_body={'error': 'Access denied: Admin role required'})

    product_id = request.matchdict['id']
    product = request.dbsession.query(Product).filter_by(id=product_id).first()
    if not product:
        raise HTTPNotFound(json_body={'error': 'Product not found'})

    try:
        request.dbsession.delete(product)
        return {'message': 'Product deleted successfully'}
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': f'Failed to delete product: {e}'})

```

## File: `bohe_backend\views\__init__.py`

```

```

## File: `bohe_backend\cors.py`

```
# In a file called tweens.py or in the main file
from pyramid.response import Response
from pyramid.httpexceptions import HTTPForbidden

def cors_tween_factory(handler, registry):
    def cors_tween(request):
        # Allow specific origin (not *)
        allowed_origin = 'http://localhost:3000'

        if request.method == 'OPTIONS':
            # Preflight response
            response = request.response
            response.headers['Access-Control-Allow-Origin'] = allowed_origin
            response.headers['Access-Control-Allow-Credentials'] = 'true'
            response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
            response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
            response.headers['Access-Control-Max-Age'] = '3600'

            return response

        # Actual response
        response = handler(request)
        response.headers['Access-Control-Allow-Origin'] = allowed_origin
        response.headers['Access-Control-Allow-Credentials'] = 'true'
        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'

        return response

    return cors_tween
```

## File: `bohe_backend\pshell.py`

```
from . import models

def setup(env):
    request = env['request']

    # start a transaction
    request.tm.begin()

    # inject some vars into the shell builtins
    env['tm'] = request.tm
    env['dbsession'] = request.dbsession
    env['models'] = models

```

## File: `bohe_backend\routes.py`

```
def includeme(config):
    config.add_static_view('static', 'static', cache_max_age=3600)
    config.add_route('home', '/')

    # Authentication and User Management Routes
    config.add_route('register', '/register')
    config.add_route('login', '/login')
    config.add_route('logout', '/logout')

    # Product Routes
    config.add_route('products', '/products')
    config.add_route('product_by_id', '/products/{id}')

    # Order Routes
    config.add_route('orders', '/orders')
    config.add_route('my_orders', '/my-orders')
    config.add_route('order_by_id', '/orders/{id}')

    # Order Item Routes (read-only direct access, modification via Order)
    config.add_route('order_items_by_order', '/orders/{order_id}/items')
    config.add_route('order_item_by_id', '/order-items/{id}')
```

## File: `bohe_backend\security.py`

```
from pyramid.security import Allow, Everyone, Authenticated, Deny
from .models.user import User  # Import User model di sini

class RootFactory:
    __acl__ = [
        # Memberikan akses 'view' kepada semua user yang terautentikasi.
        # Ini bisa digunakan untuk basic access control jika ada resource umum
        # yang hanya bisa dilihat oleh user yang sudah login.
        (Allow, Authenticated, 'view'),

        # Memberikan permission 'admin_access' kepada user yang berada dalam grup 'admin'.
        # Grup ini ditentukan oleh fungsi groupfinder.
        (Allow, 'group:admin', 'admin_access'),

        # Memberikan permission 'user_access' kepada user yang berada dalam grup 'user'.
        # Ini juga berlaku untuk admin karena admin secara implisit seringkali
        # dianggap memiliki semua hak akses user biasa.
        (Allow, 'group:user', 'user_access'),
        (Allow, 'group:admin', 'user_access'), # Admin juga punya akses user

        # Memberikan permission 'public_access' kepada siapa saja (termasuk yang tidak login).
        # Gunakan ini untuk rute yang tidak memerlukan autentikasi atau otorisasi,
        # seperti melihat daftar produk.
        (Allow, Everyone, 'public_access'),

        # Deny all other access by default if not explicitly allowed above.
        # Ini adalah fallback yang bagus untuk keamanan.
        (Deny, Everyone, 'all_permissions'),
    ]

    def __init__(self, request):
        """
        Inisialisasi RootFactory.
        request diperlukan untuk mengakses dbsession di groupfinder dan is_admin.
        """
        pass

def groupfinder(userid, request):
    """
    Fungsi callback untuk AuthTktAuthenticationPolicy.
    Menentukan group yang dimiliki oleh user berdasarkan role dari database.
    """
    if not userid:
        # Jika tidak ada userid (user tidak terautentikasi), kembalikan None.
        return None

    # Mengambil user dari database berdasarkan userid
    user = request.dbsession.query(User).filter_by(id=userid).first()

    if user and user.role:
        # Jika user ditemukan dan memiliki role, kembalikan list grupnya.
        # Penting: Awali dengan 'group:' sesuai konvensi Pyramid ACL.
        return ['group:' + user.role]

    # Jika user tidak ditemukan atau tidak memiliki role, kembalikan None.
    # Ini akan membuat user tidak memiliki grup dan hanya bergantung pada
    # permission Everyone atau Authenticated.
    return None

def is_admin(request):
    """
    Helper function untuk memeriksa apakah user yang sedang login adalah admin.
    Berguna di view untuk melakukan cek tambahan atau memberikan pesan error yang lebih spesifik.
    """
    # Mengakses authenticated_userid dari request.
    # Nilainya akan diisi oleh AuthTktAuthenticationPolicy setelah autentikasi sukses.
    userid = request.authenticated_userid

    if not userid:
        # Jika tidak ada userid, berarti user tidak terautentikasi sama sekali.
        return False

    # Mengambil objek user dari database.
    user = request.dbsession.query(User).filter_by(id=userid).first()

    # Memastikan user ada dan rolenya adalah 'admin'.
    return user and user.role == 'admin'
```

## File: `bohe_backend\tests.py`

```
import unittest
import transaction

from pyramid import testing


def dummy_request(dbsession):
    return testing.DummyRequest(dbsession=dbsession)


class BaseTest(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp(settings={
            'sqlalchemy.url': 'sqlite:///:memory:'
        })
        self.config.include('.models')
        settings = self.config.get_settings()

        from .models import (
            get_engine,
            get_session_factory,
            get_tm_session,
            )

        self.engine = get_engine(settings)
        session_factory = get_session_factory(self.engine)

        self.session = get_tm_session(session_factory, transaction.manager)

    def init_database(self):
        from .models.meta import Base
        Base.metadata.create_all(self.engine)

    def tearDown(self):
        from .models.meta import Base

        testing.tearDown()
        transaction.abort()
        Base.metadata.drop_all(self.engine)


class TestMyViewSuccessCondition(BaseTest):

    def setUp(self):
        super(TestMyViewSuccessCondition, self).setUp()
        self.init_database()

        from .models import MyModel

        model = MyModel(name='one', value=55)
        self.session.add(model)

    def test_passing_view(self):
        from .views.default import my_view
        info = my_view(dummy_request(self.session))
        self.assertEqual(info['one'].name, 'one')
        self.assertEqual(info['project'], 'bohe-backend')


class TestMyViewFailureCondition(BaseTest):

    def test_failing_view(self):
        from .views.default import my_view
        info = my_view(dummy_request(self.session))
        self.assertEqual(info.status_int, 500)

```

## File: `bohe_backend\__init__.py`

```
from pyramid.config import Configurator
from pyramid.authentication import AuthTktAuthenticationPolicy
from pyramid.authorization import ACLAuthorizationPolicy
from .security import groupfinder, RootFactory
from pyramid.renderers import JSON
from .cors import cors_tween_factory

def main(global_config, **settings):
    """ This function returns a Pyramid WSGI application.
    """
    with Configurator(settings=settings) as config:
        # Authentication and Authorization setup
        authn_policy = AuthTktAuthenticationPolicy(
            settings['auth.secret'],
            callback=groupfinder,
            hashalg='sha512'
        )

        # Correctly reference the cors_tween_factory function
        config.add_tween('bohe_backend.cors.cors_tween_factory')
        config.add_renderer('json', JSON(indent=4))

        authz_policy = ACLAuthorizationPolicy()
        config.set_authentication_policy(authn_policy)
        config.set_authorization_policy(authz_policy)
        config.set_root_factory(RootFactory)

        config.include('pyramid_jinja2')
        config.include('.models')
        config.include('.routes')
        config.scan()
    return config.make_wsgi_app()


```

## File: `bohe_backend\alembic\env.py`

```
"""Pyramid bootstrap environment. """
from alembic import context
from pyramid.paster import get_appsettings, setup_logging
from sqlalchemy import engine_from_config

from bohe_backend.models.meta import Base

config = context.config

setup_logging(config.config_file_name)

settings = get_appsettings(config.config_file_name)
target_metadata = Base.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    context.configure(url=settings['sqlalchemy.url'])
    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    engine = engine_from_config(settings, prefix='sqlalchemy.')

    connection = engine.connect()
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    try:
        with context.begin_transaction():
            context.run_migrations()
    finally:
        connection.close()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

```

## File: `bohe_backend\alembic\script.py.mako`

```
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade():
    ${upgrades if upgrades else "pass"}


def downgrade():
    ${downgrades if downgrades else "pass"}

```

## File: `bohe_backend\alembic\versions\20250531_53639a18404b.py`

```
"""create bohe table

Revision ID: 53639a18404b
Revises:
Create Date: 2025-05-31 20:23:59.920660

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '53639a18404b'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('products',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('price', sa.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('image_url', sa.String(), nullable=True),
    sa.Column('stock', sa.Integer(), server_default='0', nullable=False),
    sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_products'))
    )
    op.create_table('users',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('username', sa.String(), nullable=False),
    sa.Column('email', sa.String(), nullable=False),
    sa.Column('password', sa.String(), nullable=False),
    sa.Column('role', sa.String(), server_default='user', nullable=False),
    sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_users')),
    sa.UniqueConstraint('email', name=op.f('uq_users_email')),
    sa.UniqueConstraint('username', name=op.f('uq_users_username'))
    )
    op.create_table('orders',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('user_id', sa.String(), nullable=False),
    sa.Column('order_date', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.Column('total_amount', sa.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('customer_name', sa.String(), nullable=False),
    sa.Column('phone_number', sa.String(), nullable=False),
    sa.Column('address', sa.Text(), nullable=False),
    sa.Column('payment_method', sa.String(), nullable=False),
    sa.Column('status', sa.String(), server_default='pending_payment', nullable=False),
    sa.Column('proof_of_payment_url', sa.String(), nullable=True),
    sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_orders_user_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_orders'))
    )
    op.create_table('order_items',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('order_id', sa.String(), nullable=False),
    sa.Column('product_id', sa.String(), nullable=False),
    sa.Column('quantity', sa.Integer(), nullable=False),
    sa.Column('price_at_purchase', sa.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
    sa.ForeignKeyConstraint(['order_id'], ['orders.id'], name=op.f('fk_order_items_order_id_orders')),
    sa.ForeignKeyConstraint(['product_id'], ['products.id'], name=op.f('fk_order_items_product_id_products')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_order_items'))
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('order_items')
    op.drop_table('orders')
    op.drop_table('users')
    op.drop_table('products')
    # ### end Alembic commands ###

```

## File: `bohe_backend\alembic\versions\README.txt`

```
Placeholder for alembic versions
```

## File: `bohe_backend\models\meta.py`

```
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.schema import MetaData

# Recommended naming convention used by Alembic, as various different database
# providers will autogenerate vastly different names making migrations more
# difficult. See: http://alembic.zzzcomputing.com/en/latest/naming.html
NAMING_CONVENTION = {
    "ix": "ix_%(column_0_label)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s"
}

metadata = MetaData(naming_convention=NAMING_CONVENTION)
Base = declarative_base(metadata=metadata)

```

## File: `bohe_backend\models\order.py`

```
from sqlalchemy import Column, String, Text, DECIMAL, TIMESTAMP, ForeignKey, text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from .meta import Base
import uuid

class Order(Base):
    __tablename__ = 'orders'

    id = Column(String, primary_key=True)
    user_id = Column(String, ForeignKey('users.id'), nullable=False)
    order_date = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"))
    total_amount = Column(DECIMAL(10, 2), nullable=False)
    customer_name = Column(String, nullable=False)
    phone_number = Column(String, nullable=False)
    address = Column(Text, nullable=False)
    payment_method = Column(String, nullable=False)
    status = Column(String, nullable=False, server_default='pending_payment')
    proof_of_payment_url = Column(String)
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"), onupdate=text("CURRENT_TIMESTAMP"))

    user = relationship("User", backref="orders")
    items = relationship("OrderItem", back_populates="order")

    def to_dict(self):
        return {
            "id": str(self.id),
            "user_id": str(self.user_id),
            "order_date": self.order_date.isoformat(),
            "total_amount": float(self.total_amount),
            "customer_name": self.customer_name,
            "phone_number": self.phone_number,
            "address": self.address,
            "payment_method": self.payment_method,
            "status": self.status,
            "proof_of_payment_url": self.proof_of_payment_url,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
        }

    def __repr__(self):
        return f"<Order(id='{self.id}', user_id='{self.user_id}', total_amount='{self.total_amount}', status='{self.status}')>"
```

## File: `bohe_backend\models\order_item.py`

```
from sqlalchemy import Column, String, Integer, DECIMAL, TIMESTAMP, ForeignKey, text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from .meta import Base
import uuid

class OrderItem(Base):
    __tablename__ = 'order_items'

    id = Column(String, primary_key=True)
    order_id = Column(String, ForeignKey('orders.id'), nullable=False)
    product_id = Column(String, ForeignKey('products.id'), nullable=False)
    quantity = Column(Integer, nullable=False)
    price_at_purchase = Column(DECIMAL(10, 2), nullable=False)
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"), onupdate=text("CURRENT_TIMESTAMP"))

    order = relationship("Order", back_populates="items")
    product = relationship("Product")

    def to_dict(self):
        return {
            "id": str(self.id),
            "order_id": str(self.order_id),
            "product_id": str(self.product_id),
            "quantity": self.quantity,
            "price_at_purchase": float(self.price_at_purchase),
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
        }

    def __repr__(self):
        return f"<OrderItem(order_id='{self.order_id}', product_id='{self.product_id}', quantity='{self.quantity}')>"
```

## File: `bohe_backend\models\product.py`

```
from sqlalchemy import Column, String, Text, DECIMAL, Integer, TIMESTAMP, text
from sqlalchemy.dialects.postgresql import UUID
from .meta import Base
import uuid

class Product(Base):
    __tablename__ = 'products'

    id = Column(String, primary_key=True)
    name = Column(String, nullable=False)
    description = Column(Text)
    price = Column(DECIMAL(10, 2), nullable=False)
    image_url = Column(String)
    stock = Column(Integer, nullable=False, server_default='0')
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"), onupdate=text("CURRENT_TIMESTAMP"))

    def to_dict(self):
        return {
            "id": str(self.id),
            "name": self.name,
            "description": self.description,
            "price": float(self.price),
            "image_url": self.image_url,
            "stock": self.stock,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
        }

    def __repr__(self):
        return f"<Product(name='{self.name}', price='{self.price}', stock='{self.stock}')>"
```

## File: `bohe_backend\models\user.py`

```
from sqlalchemy import Column, String, TIMESTAMP, text
from sqlalchemy.dialects.postgresql import UUID
from .meta import Base
from passlib.hash import bcrypt
import uuid

class User(Base):
    __tablename__ = 'users'

    id = Column(String, primary_key=True)
    username = Column(String, nullable=False, unique=True)
    email = Column(String, nullable=False, unique=True)
    password = Column(String, nullable=False)
    role = Column(String, nullable=False, server_default='user')
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP"), onupdate=text("CURRENT_TIMESTAMP"))

    def set_password(self, raw_password):
        self.password = bcrypt.hash(raw_password)

    def check_password(self, raw_password):
        return bcrypt.verify(raw_password, self.password)

    def to_dict(self):
        return {
            "id": str(self.id),
            "username": self.username,
            "email": self.email,
            "role": self.role,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
        }

    def __repr__(self):
        return f"<User(username='{self.username}', email='{self.email}', role='{self.role}')>"
```

## File: `bohe_backend\models\__init__.py`

```
from sqlalchemy import engine_from_config
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import configure_mappers
import zope.sqlalchemy

# import or define all models here to ensure they are attached to the
# Base.metadata prior to any initialization routines

from .meta import Base
from .user import User
from .product import Product
from .order import Order
from .order_item import OrderItem

# run configure_mappers after defining all of the models to ensure
# all relationships can be setup
configure_mappers()


def get_engine(settings, prefix='sqlalchemy.'):
    return engine_from_config(settings, prefix)


def get_session_factory(engine):
    factory = sessionmaker()
    factory.configure(bind=engine)
    return factory


def get_tm_session(session_factory, transaction_manager):
    """
    Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.

    This function will hook the session to the transaction manager which
    will take care of committing any changes.

    - When using pyramid_tm it will automatically be committed or aborted
      depending on whether an exception is raised.

    - When using scripts you should wrap the session in a manager yourself.
      For example::

          import transaction

          engine = get_engine(settings)
          session_factory = get_session_factory(engine)
          with transaction.manager:
              dbsession = get_tm_session(session_factory, transaction.manager)

    """
    dbsession = session_factory()
    zope.sqlalchemy.register(
        dbsession, transaction_manager=transaction_manager)
    return dbsession


def includeme(config):
    """
    Initialize the model for a Pyramid app.

    Activate this setup using ``config.include('bohe_backend.models')``.

    """
    settings = config.get_settings()
    settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager'

    # use pyramid_tm to hook the transaction lifecycle to the request
    config.include('pyramid_tm')

    # use pyramid_retry to retry a request when transient exceptions occur
    config.include('pyramid_retry')

    session_factory = get_session_factory(get_engine(settings))
    config.registry['dbsession_factory'] = session_factory

    # make request.dbsession available for use in Pyramid
    config.add_request_method(
        # r.tm is the transaction manager used by pyramid_tm
        lambda r: get_tm_session(session_factory, r.tm),
        'dbsession',
        reify=True
    )

```

## File: `bohe_backend\scripts\initialize_db.py`

```
import argparse
import sys
import uuid
from datetime import datetime

from pyramid.paster import bootstrap, setup_logging
from sqlalchemy.exc import OperationalError

from ..models.user import User
from ..models.product import Product
from ..models.order import Order
from ..models.order_item import OrderItem


def setup_models(dbsession):
    """
    Add sample data for the Bohe perfume e-commerce database.
    """
    print("Seeding sample data...")

    # Sample User
    user1_id = str(uuid.uuid4())
    user1 = User(
        id=user1_id,
        username="john_doe",
        email="john.doe@example.com",
        role="user",
    )
    user1.set_password("securepassword123")

    user2_id = str(uuid.uuid4())
    user2 = User(
        id=user2_id,
        username="jane_admin",
        email="jane.admin@example.com",
        role="admin",
    )
    user2.set_password("adminpassword123")

    dbsession.add_all([user1, user2])
    print("Users added.")

    # Sample Products
    product1_id = str(uuid.uuid4())
    product1 = Product(
        id=product1_id,
        name="Bohe Classic Eau de Parfum",
        description="A timeless and elegant fragrance with notes of rose and sandalwood.",
        price=75.00,
        image_url="https://example.com/bohe-classic.jpg",
        stock=100,
    )

    product2_id = str(uuid.uuid4())
    product2 = Product(
        id=product2_id,
        name="Bohe Fresh Mist",
        description="A light and refreshing body mist, perfect for daily use.",
        price=30.50,
        image_url="https://example.com/bohe-fresh.jpg",
        stock=200,
    )

    product3_id = str(uuid.uuid4())
    product3 = Product(
        id=product3_id,
        name="Bohe Oud Intense",
        description="Deep and rich oud fragrance for a sophisticated evening.",
        price=120.00,
        image_url="https://example.com/bohe-oud.jpg",
        stock=50,
    )

    dbsession.add_all([product1, product2, product3])
    print("Products added.")

    # Sample Order for user1
    order1_id = str(uuid.uuid4())
    order1 = Order(
        id=order1_id,
        user_id=user1.id,
        order_date=datetime.now(),
        total_amount=0.00, # Will be calculated by order items
        customer_name="John Doe",
        phone_number="081234567890",
        address="Jl. Melati No. 10, Kota Metro, Lampung",
        payment_method="QRIS",
        status="completed",
        proof_of_payment_url="https://example.com/proof_payment_order1.jpg",
    )
    dbsession.add(order1)
    dbsession.flush() # Flush to get order1.id for order items

    # Sample Order Items for order1
    order_item1_id = str(uuid.uuid4())
    order_item1 = OrderItem(
        id=order_item1_id,
        order_id=order1.id,
        product_id=product1.id,
        quantity=2,
        price_at_purchase=product1.price,
    )

    order_item2_id = str(uuid.uuid4())
    order_item2 = OrderItem(
        id=order_item2_id,
        order_id=order1.id,
        product_id=product2.id,
        quantity=1,
        price_at_purchase=product2.price,
    )

    dbsession.add_all([order_item1, order_item2])
    print("Order and Order Items added.")

    # Update total_amount for order1 based on its items
    order1.total_amount = (order_item1.quantity * order_item1.price_at_purchase) + \
                          (order_item2.quantity * order_item2.price_at_purchase)
    dbsession.add(order1) # Re-add to persist the update

    print("Sample data seeding complete.")


def parse_args(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'config_uri',
        help='Configuration file, e.g., development.ini',
    )
    return parser.parse_args(argv[1:])


def main(argv=sys.argv):
    args = parse_args(argv)
    setup_logging(args.config_uri)
    env = bootstrap(args.config_uri)

    try:
        with env['request'].tm:
            dbsession = env['request'].dbsession
            setup_models(dbsession)
            print("✅ Sample data inserted successfully.")
    except OperationalError as err:
        print("❌ OperationalError:", err)
        print('''
Database connection failed. Possible causes:
1. You may need to initialize the tables using alembic: `alembic upgrade head`
2. The database server may not be running or misconfigured in development.ini.
''')
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        print("Please check your database models and connection.")
```

## File: `bohe_backend\scripts\__init__.py`

```
# package

```

## File: `bohe_backend\static\theme.css`

```
@import url(//fonts.googleapis.com/css?family=Open+Sans:300,400,600,700);
body {
  font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-weight: 300;
  color: #ffffff;
  background: #bc2131;
}
h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-weight: 300;
}
p {
  font-weight: 300;
}
.font-normal {
  font-weight: 400;
}
.font-semi-bold {
  font-weight: 600;
}
.font-bold {
  font-weight: 700;
}
.starter-template {
  margin-top: 250px;
}
.starter-template .content {
  margin-left: 10px;
}
.starter-template .content h1 {
  margin-top: 10px;
  font-size: 60px;
}
.starter-template .content h1 .smaller {
  font-size: 40px;
  color: #f2b7bd;
}
.starter-template .content .lead {
  font-size: 25px;
  color: #f2b7bd;
}
.starter-template .content .lead .font-normal {
  color: #ffffff;
}
.starter-template .links {
  float: right;
  right: 0;
  margin-top: 125px;
}
.starter-template .links ul {
  display: block;
  padding: 0;
  margin: 0;
}
.starter-template .links ul li {
  list-style: none;
  display: inline;
  margin: 0 10px;
}
.starter-template .links ul li:first-child {
  margin-left: 0;
}
.starter-template .links ul li:last-child {
  margin-right: 0;
}
.starter-template .links ul li.current-version {
  color: #f2b7bd;
  font-weight: 400;
}
.starter-template .links ul li a, a {
  color: #f2b7bd;
  text-decoration: underline;
}
.starter-template .links ul li a:hover, a:hover {
  color: #ffffff;
  text-decoration: underline;
}
.starter-template .links ul li .icon-muted {
  color: #eb8b95;
  margin-right: 5px;
}
.starter-template .links ul li:hover .icon-muted {
  color: #ffffff;
}
.starter-template .copyright {
  margin-top: 10px;
  font-size: 0.9em;
  color: #f2b7bd;
  text-transform: lowercase;
  float: right;
  right: 0;
}
@media (max-width: 1199px) {
  .starter-template .content h1 {
    font-size: 45px;
  }
  .starter-template .content h1 .smaller {
    font-size: 30px;
  }
  .starter-template .content .lead {
    font-size: 20px;
  }
}
@media (max-width: 991px) {
  .starter-template {
    margin-top: 0;
  }
  .starter-template .logo {
    margin: 40px auto;
  }
  .starter-template .content {
    margin-left: 0;
    text-align: center;
  }
  .starter-template .content h1 {
    margin-bottom: 20px;
  }
  .starter-template .links {
    float: none;
    text-align: center;
    margin-top: 60px;
  }
  .starter-template .copyright {
    float: none;
    text-align: center;
  }
}
@media (max-width: 767px) {
  .starter-template .content h1 .smaller {
    font-size: 25px;
    display: block;
  }
  .starter-template .content .lead {
    font-size: 16px;
  }
  .starter-template .links {
    margin-top: 40px;
  }
  .starter-template .links ul li {
    display: block;
    margin: 0;
  }
  .starter-template .links ul li .icon-muted {
    display: none;
  }
  .starter-template .copyright {
    margin-top: 20px;
  }
}

```

## File: `bohe_backend\templates\404.jinja2`

```
{% extends "layout.jinja2" %}

{% block content %}
<div class="content">
  <h1><span class="font-semi-bold">Pyramid</span> <span class="smaller">Alchemy scaffold</span></h1>
  <p class="lead"><span class="font-semi-bold">404</span> Page Not Found</p>
</div>
{% endblock content %}

```

## File: `bohe_backend\templates\layout.jinja2`

```
<!DOCTYPE html>
<html lang="{{request.locale_name}}">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="pyramid web application">
    <meta name="author" content="Pylons Project">
    <link rel="shortcut icon" href="{{request.static_url('bohe_backend:static/pyramid-16x16.png')}}">

    <title>Cookiecutter Alchemy project for the Pyramid Web Framework</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

    <!-- Custom styles for this scaffold -->
    <link href="{{request.static_url('bohe_backend:static/theme.css')}}" rel="stylesheet">

    <!-- HTML5 shiv and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js" integrity="sha384-0s5Pv64cNZJieYFkXYOTId2HMA2Lfb6q2nAcx2n0RTLUnCAoTTsS0nKEO27XyKcY" crossorigin="anonymous"></script>
      <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js" integrity="sha384-ZoaMbDF+4LeFxg6WdScQ9nnR1QC2MIRxA1O9KWEXQwns1G8UNyIEZIQidzb0T1fo" crossorigin="anonymous"></script>
    <![endif]-->
  </head>

  <body>

    <div class="starter-template">
      <div class="container">
        <div class="row">
          <div class="col-md-2">
            <img class="logo img-responsive" src="{{request.static_url('bohe_backend:static/pyramid.png') }}" alt="pyramid web framework">
          </div>
          <div class="col-md-10">
            {% block content %}
                <p>No content</p>
            {% endblock content %}
          </div>
        </div>
        <div class="row">
          <div class="links">
            <ul>
              <li><i class="glyphicon glyphicon-cog icon-muted"></i><a href="https://github.com/Pylons/pyramid">Github Project</a></li>
              <li><i class="glyphicon glyphicon-globe icon-muted"></i><a href="https://webchat.freenode.net/?channels=pyramid">IRC Channel</a></li>
              <li><i class="glyphicon glyphicon-home icon-muted"></i><a href="https://pylonsproject.org">Pylons Project</a></li>
            </ul>
          </div>
        </div>
        <div class="row">
          <div class="copyright">
            Copyright &copy; Pylons Project
          </div>
        </div>
      </div>
    </div>


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="//code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  </body>
</html>

```

## File: `bohe_backend\templates\mytemplate.jinja2`

```
{% extends "layout.jinja2" %}

{% block content %}
<div class="content">
  <h1><span class="font-semi-bold">Pyramid</span> <span class="smaller">Alchemy project</span></h1>
  <p class="lead">Welcome to <span class="font-normal">{{project}}</span>, a&nbsp;Pyramid application generated&nbsp;by<br><span class="font-normal">Cookiecutter</span>.</p>
</div>
{% endblock content %}
```

## File: `bohe_backend\views\auth.py`

```
from pyramid.view import view_config
from pyramid.response import Response
from pyramid.httpexceptions import HTTPBadRequest, HTTPConflict, HTTPUnauthorized
from pyramid.security import remember, forget
from ..models.user import User
from uuid import uuid4

def require_fields(data, required_fields):
    missing = [f for f in required_fields if not data.get(f)]
    if missing:
        raise HTTPBadRequest(json_body={'error': f'Missing fields: {", ".join(missing)}'})

@view_config(route_name='register', request_method='POST', renderer='json')
def register(request):
    data = request.json_body

    try:
        require_fields(data, ['username', 'email', 'password'])
    except HTTPBadRequest as e:
        return e

    username = data['username']
    email = data['email']
    password = data['password']
    role = data.get('role', 'user')

    if request.dbsession.query(User).filter_by(email=email).first():
        return HTTPConflict(json_body={'error': 'Email already exists'})

    if request.dbsession.query(User).filter_by(username=username).first():
        return HTTPConflict(json_body={'error': 'Username already exists'})

    new_user = User(
        id=str(uuid4()),
        username=username,
        email=email,
        role=role
    )
    new_user.set_password(password)
    request.dbsession.add(new_user)
    request.dbsession.flush()

    return {
        'message': 'Registration successful',
        'user': new_user.to_dict()
    }

@view_config(route_name='login', request_method='POST', renderer='json')
def login(request):
    data = request.json_body

    try:
        require_fields(data, ['email', 'password'])
    except HTTPBadRequest as e:
        return e

    email = data['email']
    password = data['password']
    user = request.dbsession.query(User).filter_by(email=email).first()

    if not user or not user.check_password(password):
        return HTTPUnauthorized(json_body={'error': 'Invalid credentials'})

    headers = remember(request, user.id)

    return Response(
        json_body={
            'message': 'Login successful',
            'user': user.to_dict()
        },
        headers=headers,
        content_type='application/json'
    )

@view_config(route_name='logout', request_method='POST', renderer='json')
def logout(request):
    headers = forget(request)

    return Response(
        json_body={'message': 'Logout successful'},
        headers=headers,
        content_type='application/json'
    )

```

## File: `bohe_backend\views\default.py`

```
from pyramid.response import Response
from pyramid.view import view_config

@view_config(route_name='home', renderer='json')
def home_view(request):
    return {'message': 'Welcome to Bohe API'}
```

## File: `bohe_backend\views\notfound.py`

```
from pyramid.view import notfound_view_config

@notfound_view_config(renderer='../templates/404.jinja2')
def notfound_view(request):
    request.response.status = 404
    return {}

```

## File: `bohe_backend\views\orders.py`

```
from pyramid.view import view_config
from pyramid.httpexceptions import HTTPNotFound, HTTPBadRequest, HTTPForbidden, HTTPUnauthorized
from sqlalchemy.exc import IntegrityError
from uuid import uuid4
from datetime import datetime
from ..models.order import Order
from ..models.order_item import OrderItem
from ..models.product import Product
from ..security import is_admin

def require_fields(data, required_fields):
    missing = [f for f in required_fields if not data.get(f)]
    if missing:
        raise HTTPBadRequest(json_body={'error': f'Missing fields: {", ".join(missing)}'})

# View to list all orders (admin only)
@view_config(route_name='orders', request_method='GET', renderer='json', permission='admin_access')
def get_all_orders(request):
    if not is_admin(request):
        raise HTTPForbidden(json_body={'error': 'Access denied: Admin role required'})

    orders = request.dbsession.query(Order).all()
    return {'orders': [o.to_dict() for o in orders]}

# View to list orders for the authenticated user (user or admin)
@view_config(route_name='my_orders', request_method='GET', renderer='json', permission='user_access')
def get_my_orders(request):
    userid = request.authenticated_userid
    if not userid:
        raise HTTPUnauthorized(json_body={'error': 'Authentication required'})

    orders = request.dbsession.query(Order).filter_by(user_id=userid).all()
    return {'orders': [o.to_dict() for o in orders]}

# View to get a single order by ID (owner or admin only)
@view_config(route_name='order_by_id', request_method='GET', renderer='json', permission='user_access')
def get_order(request):
    order_id = request.matchdict['id']
    order = request.dbsession.query(Order).filter_by(id=order_id).first()
    if not order:
        raise HTTPNotFound(json_body={'error': 'Order not found'})

    userid = request.authenticated_userid
    if not userid:
        raise HTTPUnauthorized(json_body={'error': 'Authentication required'})

    if not is_admin(request) and str(order.user_id) != userid:
        raise HTTPForbidden(json_body={'error': 'Access denied: You can only view your own orders'})

    return order.to_dict()

# View to create a new order (authenticated users)
@view_config(route_name='orders', request_method='POST', renderer='json', permission='user_access')
def create_order(request):
    userid = request.authenticated_userid
    if not userid:
        raise HTTPUnauthorized(json_body={'error': 'Authentication required'})

    data = request.json_body
    try:
        require_fields(data, ['customer_name', 'phone_number', 'address', 'payment_method', 'items'])
        if not isinstance(data['items'], list) or not data['items']:
            raise HTTPBadRequest(json_body={'error': 'Invalid or empty "items" list'})
    except HTTPBadRequest as e:
        return e

    try:
        new_order = Order(
            id=str(uuid4()),
            user_id=userid,
            customer_name=data['customer_name'],
            phone_number=data['phone_number'],
            address=data['address'],
            payment_method=data['payment_method'],
            status=data.get('status', 'pending_payment'),
            proof_of_payment_url=data.get('proof_of_payment_url'),
            total_amount=0.00
        )
        request.dbsession.add(new_order)
        request.dbsession.flush()

        total_amount = 0
        for item_data in data['items']:
            require_fields(item_data, ['product_id', 'quantity'])
            product = request.dbsession.query(Product).filter_by(id=item_data['product_id']).first()
            if not product:
                raise HTTPBadRequest(json_body={'error': f"Product with ID {item_data['product_id']} not found"})
            if item_data['quantity'] <= 0:
                raise HTTPBadRequest(json_body={'error': 'Quantity must be positive'})
            if product.stock < item_data['quantity']:
                raise HTTPBadRequest(json_body={'error': f"Insufficient stock for product {product.name}. Available: {product.stock}"})

            new_order_item = OrderItem(
                id=str(uuid4()),
                order_id=new_order.id,
                product_id=product.id,
                quantity=item_data['quantity'],
                price_at_purchase=product.price
            )
            request.dbsession.add(new_order_item)
            total_amount += (new_order_item.quantity * new_order_item.price_at_purchase)

            product.stock -= item_data['quantity']
            request.dbsession.add(product)

        new_order.total_amount = total_amount
        request.dbsession.add(new_order)

        return {'message': 'Order created successfully', 'order': new_order.to_dict()}
    except IntegrityError:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': 'Failed to create order. Check data integrity.'})
    except HTTPBadRequest as e:
        request.dbsession.rollback()
        return e
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': f'An error occurred: {e}'})

# View to update order status (admin only)
@view_config(route_name='order_by_id', request_method='PUT', renderer='json', permission='admin_access')
def update_order(request):
    if not is_admin(request):
        raise HTTPForbidden(json_body={'error': 'Access denied: Admin role required'})

    order_id = request.matchdict['id']
    order = request.dbsession.query(Order).filter_by(id=order_id).first()
    if not order:
        raise HTTPNotFound(json_body={'error': 'Order not found'})

    data = request.json_body

    allowed_status_updates = ['pending_payment', 'waiting_confirmation', 'processing', 'shipped', 'completed', 'cancelled']
    if 'status' in data:
        if data['status'] not in allowed_status_updates:
            raise HTTPBadRequest(json_body={'error': 'Invalid status value'})
        order.status = data['status']
    if 'proof_of_payment_url' in data:
        order.proof_of_payment_url = data['proof_of_payment_url']
    if 'customer_name' in data:
        order.customer_name = data['customer_name']
    if 'phone_number' in data:
        order.phone_number = data['phone_number']
    if 'address' in data:
        order.address = data['address']
    if 'payment_method' in data:
        order.payment_method = data['payment_method']

    try:
        request.dbsession.flush()
        return {'message': 'Order updated successfully', 'order': order.to_dict()}
    except IntegrityError:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': 'Failed to update order. Check data integrity.'})
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': f'An error occurred: {e}'})

# View to delete an order (admin only)
@view_config(route_name='order_by_id', request_method='DELETE', renderer='json', permission='admin_access')
def delete_order(request):
    if not is_admin(request):
        raise HTTPForbidden(json_body={'error': 'Access denied: Admin role required'})

    order_id = request.matchdict['id']
    order = request.dbsession.query(Order).filter_by(id=order_id).first()
    if not order:
        raise HTTPNotFound(json_body={'error': 'Order not found'})

    try:
        request.dbsession.query(OrderItem).filter_by(order_id=order.id).delete()
        request.dbsession.delete(order)
        return {'message': 'Order deleted successfully'}
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': f'Failed to delete order: {e}'})

```

## File: `bohe_backend\views\order_items.py`

```
from pyramid.view import view_config
from pyramid.httpexceptions import HTTPNotFound, HTTPForbidden, HTTPUnauthorized
from ..models.order_item import OrderItem
from ..models.order import Order
from ..security import is_admin

# View to list all order items for a specific order (owner or admin only)
@view_config(route_name='order_items_by_order', request_method='GET', renderer='json', permission='user_access')
def get_order_items_for_order(request):
    order_id = request.matchdict['order_id']
    order = request.dbsession.query(Order).filter_by(id=order_id).first()
    if not order:
        raise HTTPNotFound(json_body={'error': 'Order not found'})

    userid = request.authenticated_userid
    if not userid:
        raise HTTPUnauthorized(json_body={'error': 'Authentication required'})

    if not is_admin(request) and str(order.user_id) != userid:
        raise HTTPForbidden(json_body={'error': 'Access denied: You can only view items of your own orders'})

    order_items = request.dbsession.query(OrderItem).filter_by(order_id=order_id).all()
    return {'order_items': [oi.to_dict() for oi in order_items]}

# View to get a single order item by ID (owner of order or admin only)
@view_config(route_name='order_item_by_id', request_method='GET', renderer='json', permission='user_access')
def get_order_item(request):
    order_item_id = request.matchdict['id']
    order_item = request.dbsession.query(OrderItem).filter_by(id=order_item_id).first()
    if not order_item:
        raise HTTPNotFound(json_body={'error': 'Order item not found'})

    order = request.dbsession.query(Order).filter_by(id=order_item.order_id).first()

    userid = request.authenticated_userid
    if not userid:
        raise HTTPUnauthorized(json_body={'error': 'Authentication required'})

    if not is_admin(request) and (not order or str(order.user_id) != userid):
        raise HTTPForbidden(json_body={'error': 'Access denied: You can only view items of your own orders'})

    return order_item.to_dict()

```

## File: `bohe_backend\views\products.py`

```
from pyramid.view import view_config
from pyramid.httpexceptions import HTTPNotFound, HTTPBadRequest, HTTPForbidden
from sqlalchemy.exc import IntegrityError
from uuid import uuid4
from ..models.product import Product
from ..security import is_admin

def require_fields(data, required_fields):
    missing = [f for f in required_fields if not data.get(f)]
    if missing:
        raise HTTPBadRequest(json_body={'error': f'Missing fields: {", ".join(missing)}'})

# View to list all products (publicly accessible)
@view_config(route_name='products', request_method='GET', renderer='json', permission='public_access')
def get_products(request):
    products = request.dbsession.query(Product).all()
    return {'products': [p.to_dict() for p in products]}

# View to get a single product by ID (publicly accessible)
@view_config(route_name='product_by_id', request_method='GET', renderer='json', permission='public_access')
def get_product(request):
    product_id = request.matchdict['id']
    product = request.dbsession.query(Product).filter_by(id=product_id).first()
    if not product:
        raise HTTPNotFound(json_body={'error': 'Product not found'})
    return product.to_dict()

# View to create a new product (admin only)
@view_config(route_name='products', request_method='POST', renderer='json', permission='admin_access')
def create_product(request):
    if not is_admin(request):
        raise HTTPForbidden(json_body={'error': 'Access denied: Admin role required'})

    data = request.json_body
    try:
        require_fields(data, ['name', 'price', 'stock'])
    except HTTPBadRequest as e:
        return e

    try:
        new_product = Product(
            id=str(uuid4()),
            name=data['name'],
            description=data.get('description'),
            price=data['price'],
            image_url=data.get('image_url'),
            stock=data['stock']
        )
        request.dbsession.add(new_product)
        request.dbsession.flush()
        return {'message': 'Product created successfully', 'product': new_product.to_dict()}
    except IntegrityError:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': 'Failed to create product. Check data integrity.'})
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': f'An error occurred: {e}'})

# View to update an existing product (admin only)
@view_config(route_name='product_by_id', request_method='PUT', renderer='json', permission='admin_access')
def update_product(request):
    if not is_admin(request):
        raise HTTPForbidden(json_body={'error': 'Access denied: Admin role required'})

    product_id = request.matchdict['id']
    product = request.dbsession.query(Product).filter_by(id=product_id).first()
    if not product:
        raise HTTPNotFound(json_body={'error': 'Product not found'})

    data = request.json_body

    if 'name' in data:
        product.name = data['name']
    if 'description' in data:
        product.description = data['description']
    if 'price' in data:
        product.price = data['price']
    if 'image_url' in data:
        product.image_url = data['image_url']
    if 'stock' in data:
        product.stock = data['stock']

    try:
        request.dbsession.flush()
        return {'message': 'Product updated successfully', 'product': product.to_dict()}
    except IntegrityError:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': 'Failed to update product. Check data integrity.'})
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': f'An error occurred: {e}'})

# View to delete a product (admin only)
@view_config(route_name='product_by_id', request_method='DELETE', renderer='json', permission='admin_access')
def delete_product(request):
    if not is_admin(request):
        raise HTTPForbidden(json_body={'error': 'Access denied: Admin role required'})

    product_id = request.matchdict['id']
    product = request.dbsession.query(Product).filter_by(id=product_id).first()
    if not product:
        raise HTTPNotFound(json_body={'error': 'Product not found'})

    try:
        request.dbsession.delete(product)
        return {'message': 'Product deleted successfully'}
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPBadRequest(json_body={'error': f'Failed to delete product: {e}'})

```

## File: `bohe_backend\views\__init__.py`

```

```

## File: `bohe_backend\cors.py`

```
# In a file called tweens.py or in the main file
from pyramid.response import Response
from pyramid.httpexceptions import HTTPForbidden

def cors_tween_factory(handler, registry):
    def cors_tween(request):
        # Allow specific origin (not *)
        allowed_origin = 'http://localhost:3000'

        if request.method == 'OPTIONS':
            # Preflight response
            response = request.response
            response.headers['Access-Control-Allow-Origin'] = allowed_origin
            response.headers['Access-Control-Allow-Credentials'] = 'true'
            response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
            response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
            response.headers['Access-Control-Max-Age'] = '3600'

            return response

        # Actual response
        response = handler(request)
        response.headers['Access-Control-Allow-Origin'] = allowed_origin
        response.headers['Access-Control-Allow-Credentials'] = 'true'
        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'

        return response

    return cors_tween
```

## File: `bohe_backend\pshell.py`

```
from . import models

def setup(env):
    request = env['request']

    # start a transaction
    request.tm.begin()

    # inject some vars into the shell builtins
    env['tm'] = request.tm
    env['dbsession'] = request.dbsession
    env['models'] = models

```

## File: `bohe_backend\routes.py`

```
def includeme(config):
    config.add_static_view('static', 'static', cache_max_age=3600)
    config.add_route('home', '/')

    # Authentication and User Management Routes
    config.add_route('register', '/register')
    config.add_route('login', '/login')
    config.add_route('logout', '/logout')

    # Product Routes
    config.add_route('products', '/products')
    config.add_route('product_by_id', '/products/{id}')

    # Order Routes
    config.add_route('orders', '/orders')
    config.add_route('my_orders', '/my-orders')
    config.add_route('order_by_id', '/orders/{id}')

    # Order Item Routes (read-only direct access, modification via Order)
    config.add_route('order_items_by_order', '/orders/{order_id}/items')
    config.add_route('order_item_by_id', '/order-items/{id}')
```

## File: `bohe_backend\security.py`

```
from pyramid.security import Allow, Everyone, Authenticated, Deny
from .models.user import User  # Import User model di sini

class RootFactory:
    __acl__ = [
        # Memberikan akses 'view' kepada semua user yang terautentikasi.
        # Ini bisa digunakan untuk basic access control jika ada resource umum
        # yang hanya bisa dilihat oleh user yang sudah login.
        (Allow, Authenticated, 'view'),

        # Memberikan permission 'admin_access' kepada user yang berada dalam grup 'admin'.
        # Grup ini ditentukan oleh fungsi groupfinder.
        (Allow, 'group:admin', 'admin_access'),

        # Memberikan permission 'user_access' kepada user yang berada dalam grup 'user'.
        # Ini juga berlaku untuk admin karena admin secara implisit seringkali
        # dianggap memiliki semua hak akses user biasa.
        (Allow, 'group:user', 'user_access'),
        (Allow, 'group:admin', 'user_access'), # Admin juga punya akses user

        # Memberikan permission 'public_access' kepada siapa saja (termasuk yang tidak login).
        # Gunakan ini untuk rute yang tidak memerlukan autentikasi atau otorisasi,
        # seperti melihat daftar produk.
        (Allow, Everyone, 'public_access'),

        # Deny all other access by default if not explicitly allowed above.
        # Ini adalah fallback yang bagus untuk keamanan.
        (Deny, Everyone, 'all_permissions'),
    ]

    def __init__(self, request):
        """
        Inisialisasi RootFactory.
        request diperlukan untuk mengakses dbsession di groupfinder dan is_admin.
        """
        pass

def groupfinder(userid, request):
    """
    Fungsi callback untuk AuthTktAuthenticationPolicy.
    Menentukan group yang dimiliki oleh user berdasarkan role dari database.
    """
    if not userid:
        # Jika tidak ada userid (user tidak terautentikasi), kembalikan None.
        return None

    # Mengambil user dari database berdasarkan userid
    user = request.dbsession.query(User).filter_by(id=userid).first()

    if user and user.role:
        # Jika user ditemukan dan memiliki role, kembalikan list grupnya.
        # Penting: Awali dengan 'group:' sesuai konvensi Pyramid ACL.
        return ['group:' + user.role]

    # Jika user tidak ditemukan atau tidak memiliki role, kembalikan None.
    # Ini akan membuat user tidak memiliki grup dan hanya bergantung pada
    # permission Everyone atau Authenticated.
    return None

def is_admin(request):
    """
    Helper function untuk memeriksa apakah user yang sedang login adalah admin.
    Berguna di view untuk melakukan cek tambahan atau memberikan pesan error yang lebih spesifik.
    """
    # Mengakses authenticated_userid dari request.
    # Nilainya akan diisi oleh AuthTktAuthenticationPolicy setelah autentikasi sukses.
    userid = request.authenticated_userid

    if not userid:
        # Jika tidak ada userid, berarti user tidak terautentikasi sama sekali.
        return False

    # Mengambil objek user dari database.
    user = request.dbsession.query(User).filter_by(id=userid).first()

    # Memastikan user ada dan rolenya adalah 'admin'.
    return user and user.role == 'admin'
```

## File: `bohe_backend\tests.py`

```
import unittest
import transaction

from pyramid import testing


def dummy_request(dbsession):
    return testing.DummyRequest(dbsession=dbsession)


class BaseTest(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp(settings={
            'sqlalchemy.url': 'sqlite:///:memory:'
        })
        self.config.include('.models')
        settings = self.config.get_settings()

        from .models import (
            get_engine,
            get_session_factory,
            get_tm_session,
            )

        self.engine = get_engine(settings)
        session_factory = get_session_factory(self.engine)

        self.session = get_tm_session(session_factory, transaction.manager)

    def init_database(self):
        from .models.meta import Base
        Base.metadata.create_all(self.engine)

    def tearDown(self):
        from .models.meta import Base

        testing.tearDown()
        transaction.abort()
        Base.metadata.drop_all(self.engine)


class TestMyViewSuccessCondition(BaseTest):

    def setUp(self):
        super(TestMyViewSuccessCondition, self).setUp()
        self.init_database()

        from .models import MyModel

        model = MyModel(name='one', value=55)
        self.session.add(model)

    def test_passing_view(self):
        from .views.default import my_view
        info = my_view(dummy_request(self.session))
        self.assertEqual(info['one'].name, 'one')
        self.assertEqual(info['project'], 'bohe-backend')


class TestMyViewFailureCondition(BaseTest):

    def test_failing_view(self):
        from .views.default import my_view
        info = my_view(dummy_request(self.session))
        self.assertEqual(info.status_int, 500)

```

## File: `bohe_backend\__init__.py`

```
from pyramid.config import Configurator
from pyramid.authentication import AuthTktAuthenticationPolicy
from pyramid.authorization import ACLAuthorizationPolicy
from .security import groupfinder, RootFactory
from pyramid.renderers import JSON
from .cors import cors_tween_factory

def main(global_config, **settings):
    """ This function returns a Pyramid WSGI application.
    """
    with Configurator(settings=settings) as config:
        # Authentication and Authorization setup
        authn_policy = AuthTktAuthenticationPolicy(
            settings['auth.secret'],
            callback=groupfinder,
            hashalg='sha512'
        )

        # Correctly reference the cors_tween_factory function
        config.add_tween('bohe_backend.cors.cors_tween_factory')
        config.add_renderer('json', JSON(indent=4))

        authz_policy = ACLAuthorizationPolicy()
        config.set_authentication_policy(authn_policy)
        config.set_authorization_policy(authz_policy)
        config.set_root_factory(RootFactory)

        config.include('pyramid_jinja2')
        config.include('.models')
        config.include('.routes')
        config.scan()
    return config.make_wsgi_app()


```
